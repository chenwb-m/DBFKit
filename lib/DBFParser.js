// Generated by CoffeeScript 1.7.1
(function() {
  var DBFParser, EventEmitter, Iconv, JSZip, fs,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  EventEmitter = require('events').EventEmitter;

  fs = require('fs');

  Iconv = require('iconv').Iconv;

  JSZip = require("jszip");

  DBFParser = (function(_super) {
    __extends(DBFParser, _super);

    function DBFParser(fileName, encoding) {
      this.fileName = fileName;
      this.encoding = encoding != null ? encoding : 'GBK';
      this._parseField = __bind(this._parseField, this);
      this._parseRecords = __bind(this._parseRecords, this);
      this._parseHead = __bind(this._parseHead, this);
      this.iconv = new Iconv(this.encoding, 'UTF-8//IGNORE');
      this.timeReg1 = /^(?:(?!0000)[0-9]{4}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-8])|(?:0[13-9]|1[0-2])-(?:29|30)|(?:0[13578]|1[02])-31)|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)-02-29)\s+([01][0-9]|2[0-3]):[0-5][0-9]:[0-5][0-9]$/;
    }

    DBFParser.prototype.parse = function() {
      return fs.readFile(this.fileName, (function(_this) {
        return function(err, buffer) {
          if (err) {
            throw err;
          }
          _this.emit('start');
          _this._parseHead(buffer);
          _this._parseRecords(buffer);
          return _this.emit('end');
        };
      })(this));
    };

    DBFParser.prototype.parseZip = function() {};

    DBFParser.prototype._parseHead = function(buffer) {
      var dd, field, head, i, k;
      head = {};
      head.version = this.version = buffer[0].toString();
      head.updatedDate = this.updatedDate = new Date(1900 + buffer[1], buffer[2] - 1, dd = buffer[3]);
      head.recordsCount = this.recordsCount = buffer.readUInt32LE(4, true);
      head.headOffset = this.headOffset = buffer.readUInt16LE(8, true);
      head.recordLength = this.recordLength = buffer.readUInt16LE(10, true);
      head.fields = [];
      k = 0;
      this.fields = (function() {
        var _i, _ref, _results;
        _results = [];
        for (i = _i = 32, _ref = this.headOffset - 32; _i <= _ref; i = _i += 32) {
          field = {
            name: (this.iconv.convert(buffer.slice(i, i + 11)).toString().replace(/[\u0000].*$/, '')).replace(/^[\r]+|[\n]+|[\r\n]+|[\n\r]+/, ''),
            type: (String.fromCharCode(buffer[i + 11])).replace(/[\u0000]+$/, ''),
            address: buffer.readUInt32LE(i + 12, true),
            length: buffer.readUInt8(i + 16),
            precision: buffer.readUInt8(i + 17)
          };
          if (field.name !== '') {
            head.fields[k++] = field;
          }
          _results.push(field);
        }
        return _results;
      }).call(this);
      return this.emit('head', head);
    };

    DBFParser.prototype._parseRecords = function(buffer) {
      var bufferLength, bufferTemp, curPoint, deletedFlag, endPoint, field, i, point, record, _i, _j, _len, _ref, _ref1, _ref2, _results;
      endPoint = this.headOffset + this.recordLength * this.recordsCount - 1;
      bufferLength = buffer.length;
      bufferTemp = null;
      _results = [];
      for (point = _i = _ref = this.headOffset, _ref1 = this.recordLength; _ref1 > 0 ? _i <= endPoint : _i >= endPoint; point = _i += _ref1) {
        if (!(point < bufferLength)) {
          continue;
        }
        bufferTemp = buffer.slice(point, point + this.recordLength);
        record = [];
        i = 0;
        curPoint = 1;
        deletedFlag = bufferTemp[0] === 42 || bufferTemp[0] === '*';
        _ref2 = this.fields;
        for (_j = 0, _len = _ref2.length; _j < _len; _j++) {
          field = _ref2[_j];
          if (field.name === '') {
            curPoint += field.length;
          } else {
            record[i++] = this._parseField(curPoint, curPoint += field.length, field, bufferTemp);
          }
        }
        record["_deletedFlag"] = deletedFlag;
        _results.push(this.emit('record', record));
      }
      return _results;
    };

    DBFParser.prototype._parseField = function(begin, end, field, buffer) {
      var dd, mm, value, yy;
      switch (field.type) {
        case 'C':
          value = this.iconv.convert(buffer.slice(begin, end)).toString().replace(/^\x20+|\x20+$/g, '');
          if (value) {
            if (this.timeReg1.test(value)) {
              value = new Date(value);
            }
          } else {
            value = null;
          }
          break;
        case 'N':
        case 'F':
          value = parseFloat(buffer.slice(begin, end));
          if (isNaN(value)) {
            value = null;
          }
          break;
        case 'L':
          value = buffer.slice(begin, end).toString();
          if (value === 'Y' || value === 'y' || value === 'T' || value === 't') {
            value = true;
          } else if (value === 'N' || value === 'n' || value === 'F' || value === 'f') {
            value = false;
          } else {
            value = null;
          }
          break;
        case 'D':
          yy = parseInt(buffer.slice(begin, begin + 4));
          mm = parseInt(buffer.slice(begin + 4, begin + 6) - 1);
          dd = parseInt(buffer.slice(begin + 6, begin + 8));
          if (isNaN(yy)) {
            value = null;
          } else {
            value = new Date(yy, mm, dd);
          }
          break;
        default:
          value = (buffer.slice(begin, end)).toString().replace(/^\x20+|\x20+$/g, '');
          if (!value) {
            value = null;
          }
      }
      return {
        name: field.name,
        value: value
      };
    };

    return DBFParser;

  })(EventEmitter);

  module.exports = DBFParser;

}).call(this);
