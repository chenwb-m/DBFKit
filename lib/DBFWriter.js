// Generated by CoffeeScript 1.6.3
(function() {
  var Buffer, DBFWriter, FIELDSIZE, FileKit, Iconv, JSZip, execSync, fs, lFill, path, rFill, util;

  fs = require('fs');

  util = require('util');

  path = require('path');

  Buffer = require('buffer').Buffer;

  Iconv = require('iconv').Iconv;

  JSZip = require("jszip");

  FileKit = require("./FileKit");

  execSync = require('exec-sync');

  FIELDSIZE = {
    C: 255,
    D: 8,
    N: 21,
    L: 1
  };

  lFill = function(str, len, char) {
    while (str.length < len) {
      str = char + str;
    }
    return str;
  };

  rFill = function(str, len, char) {
    while (str.length < len) {
      str = str + char;
    }
    return str;
  };

  DBFWriter = (function() {
    /*
    header: {
        name: 'name', 
        type: 'D'
    }
    */

    function DBFWriter(header, doc, fileName, dirName, options) {
      this.doc = doc;
      this.fileName = fileName;
      this.dirName = dirName != null ? dirName : "./";
      if (!(util.isArray(header))) {
        throw new Error("first paramter must be a Array object to indicate header!");
      }
      if (!(util.isArray(this.doc))) {
        throw new Error("second paramter must be a Array object hold all data to write!");
      }
      if (typeof this.fileName !== "string") {
        throw new Error("you must provide a String object as fourth paramter to indicate the file name!");
      }
      this._initOptions(options);
      this.header = [];
      this._initHeader(header);
      if (!(fs.existsSync(this.dirName))) {
        fs.mkdirSync(this.dirName);
      }
      this.pathName = path.join(this.dirName, this.fileName);
      this.iconv = new Iconv('UTF-8', this.options.encoding + '//IGNORE');
    }

    DBFWriter.prototype.write = function() {
      if (fs.existsSync(FileKit.makeSuffix(this.pathName, "dbf")) && this.options.coverIfFileExist === false) {
        throw new Error("the dbf file aready exist!");
      }
      return fs.writeFileSync(FileKit.makeSuffix(this.pathName, "dbf"), this._generate());
    };

    DBFWriter.prototype.writeZip = function() {
      var wsBuffer, zip;
      if (fs.existsSync(FileKit.makeSuffix(this.pathName, "zip")) && this.options.coverIfFileExist === false) {
        throw new Error("the file aready exist!");
      }
      wsBuffer = this._generate();
      zip = new JSZip();
      zip.file(FileKit.makeSuffix(this.fileName, "dbf"), wsBuffer, {
        compression: "DEFLATE",
        base64: false
      });
      return fs.writeFileSync(FileKit.makeSuffix(this.pathName, "zip"), zip.generate({
        type: "nodebuffer"
      }));
    };

    DBFWriter.prototype.writeZipByLocal = function() {
      var cmd, result;
      if (fs.existsSync(FileKit.makeSuffix(this.pathName, "zip")) && this.options.coverIfFileExist === false) {
        throw new Error("the zip file aready exist!");
      }
      this.write();
      cmd = "zip -m " + (FileKit.makeSuffix(this.pathName, "zip")) + " " + (FileKit.makeSuffix(this.pathName, "dbf"));
      result = execSync(cmd, true);
      if (result.stderr) {
        throw new Error(result.stderr);
      }
      if (!fs.existsSync(FileKit.makeSuffix(this.pathName, "zip"))) {
        throw new Error(result.stdout);
      }
    };

    DBFWriter.prototype._generate = function() {
      var wsBuffer;
      wsBuffer = new Buffer(32 + 32 * this.header.length + 1 + this.header.totalFieldsLength * this.doc.length + 1);
      this._writeBufferHead(wsBuffer);
      this._writeBufferBody(wsBuffer);
      return wsBuffer;
    };

    DBFWriter.prototype._initOptions = function(options) {
      this.options = {};
      if (options) {
        if (options.encoding && typeof options.encoding === 'string') {
          this.options.encoding = options.encoding;
        } else {
          this.options.encoding = 'gb2312';
        }
        if (options.coverIfFileExist === false) {
          return this.options.coverIfFileExist = options.coverIfFileExist;
        } else {
          return this.options.coverIfFileExist = true;
        }
      } else {
        this.options.encoding = 'gb2312';
        return this.options.coverIfFileExist = true;
      }
    };

    DBFWriter.prototype._initHeader = function(header) {
      var head, totalFieldsLength, _i, _len;
      totalFieldsLength = 1;
      for (_i = 0, _len = header.length; _i < _len; _i++) {
        head = header[_i];
        if (FIELDSIZE[head.type]) {
          head.size = FIELDSIZE[head.type];
          if (!head.precision) {
            head.precision = 0;
          }
          totalFieldsLength += head.size;
        } else {
          throw new Error("the type \"" + head.type + "\" in header doesn't support!");
        }
        this.header.push(head);
      }
      return this.header.totalFieldsLength = totalFieldsLength;
    };

    DBFWriter.prototype._writeBufferHead = function(wsBuffer) {
      var buf, head, k, now, offset, _i, _len, _ref;
      now = new Date();
      wsBuffer.writeUInt8(3, 0, wsBuffer.writeUInt8(now.getFullYear() - 1900, 1));
      wsBuffer.writeUInt8(now.getMonth() + 1, 2);
      wsBuffer.writeUInt8(now.getDate(), 3);
      wsBuffer.writeUInt32LE(this.doc.length, 4);
      wsBuffer.writeUInt16LE(32 + 32 * this.header.length + 1, 8);
      wsBuffer.writeUInt16LE(this.header.totalFieldsLength, 10);
      wsBuffer.fill(0, 12, 32);
      offset = 32;
      _ref = this.header;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        head = _ref[_i];
        buf = this.iconv.convert(head.name);
        k = 0;
        while (k < buf.length && k < 10) {
          wsBuffer.writeUInt8(buf.readUInt8(k++), offset++);
        }
        while (k < 11) {
          wsBuffer.writeUInt8(0, offset++);
          k++;
        }
        wsBuffer.writeUInt8(head.type.charCodeAt(0), offset++);
        wsBuffer.writeUInt32LE(0, offset);
        offset += 4;
        wsBuffer.writeUInt8(head.size, offset++);
        wsBuffer.writeUInt8(head.precision, offset++);
        wsBuffer.fill(0, offset, offset + 14);
        offset += 14;
      }
      wsBuffer.writeUInt8(13, offset++);
      return wsBuffer;
    };

    DBFWriter.prototype._writeBufferBody = function(wsBuffer) {
      var coll, head, offset, val, _i, _j, _len, _len1, _ref, _ref1;
      offset = 32 + 32 * this.header.length + 1;
      _ref = this.doc;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        coll = _ref[_i];
        wsBuffer.writeUInt8(32, offset++);
        _ref1 = this.header;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          head = _ref1[_j];
          val = coll[head.name];
          switch (head.type) {
            case 'C':
              offset = this._writeBufferString(val, head, wsBuffer, offset);
              break;
            case 'D':
              offset = this._writeBufferDate(val, head, wsBuffer, offset);
              break;
            case 'N':
              offset = this._writeBufferNumber(val, head, wsBuffer, offset);
              break;
            case 'L':
              offset = this._writeBufferLogic(val, head, wsBuffer, offset);
          }
        }
      }
      return wsBuffer.writeUInt8(26, offset);
    };

    DBFWriter.prototype._writeBufferString = function(val, head, wsBuffer, offset) {
      var buf;
      if (!val) {
        val = "";
      }
      if (val instanceof Date) {
        val = "" + (val.getFullYear()) + "-" + (lFill((val.getMonth() + 1).toString(), 2, '0')) + "-" + (lFill(val.getDate().toString(), 2, '0')) + " " + (lFill(val.getHours().toString(), 2, '0')) + ":" + (lFill(val.getMinutes().toString(), 2, '0')) + ":" + (lFill(val.getSeconds().toString(), 2, '0'));
        buf = new Buffer(val);
      } else {
        buf = this.iconv.convert(val.toString());
      }
      return this._writeBufferChar(buf, head, wsBuffer, offset);
    };

    DBFWriter.prototype._writeBufferDate = function(val, head, wsBuffer, offset) {
      var buf;
      if (!val) {
        val = "";
      }
      if (val instanceof Date) {
        val = "" + (val.getFullYear()) + (lFill((val.getMonth() + 1).toString(), 2, '0')) + (lFill(val.getDate().toString(), 2, '0'));
      }
      buf = new Buffer(val.toString());
      return this._writeBufferChar(buf, head, wsBuffer, offset);
    };

    DBFWriter.prototype._writeBufferNumber = function(val, head, wsBuffer, offset) {
      if (val !== 0 && !val) {
        val = "";
      }
      if (typeof val === 'number') {
        val = val.toFixed(head.precision);
      } else {
        val = (parseFloat(val)).toFixed(head.precision);
      }
      if (isNaN(val)) {
        val = "";
      }
      return this._writeBufferDecimal(val, head, wsBuffer, offset);
    };

    DBFWriter.prototype._writeBufferLogic = function(val, head, wsBuffer, offset) {
      if (val !== false && !val) {
        val = "?";
      }
      val = val.toString().toUpperCase().charCodeAt(0);
      wsBuffer.writeUInt8(val, offset++);
      return offset++;
    };

    DBFWriter.prototype._writeBufferChar = function(buf, head, wsBuffer, offset) {
      var k, length, size;
      k = 0;
      size = head.size;
      length = buf.length;
      while (k < length && k < size) {
        wsBuffer.writeUInt8(buf.readUInt8(k++), offset++);
      }
      if (k < size) {
        wsBuffer.fill(' ', offset, offset + size - k);
      }
      return offset = offset + size - k;
    };

    DBFWriter.prototype._writeBufferDecimal = function(val, head, wsBuffer, offset) {
      var buf, k, size;
      val = val.toString();
      k = 0;
      size = head.size;
      val = lFill(val, size, ' ');
      val = val.substring(0, size);
      buf = new Buffer(val);
      while (k < size) {
        wsBuffer.writeUInt8(buf.readUInt8(k++), offset++);
      }
      return offset;
    };

    return DBFWriter;

  })();

  module.exports = DBFWriter;

}).call(this);
